
<!doctype html>
<head>
<style>

* {
/*    max-width: 900px;
    margin: 40px auto;*/
    /*Lucida console PC, Monaco Mac, chrome dev tools fonts
    striped 0s, very clear symbol font*/
    /*Not a huge fan of the font though, looks too "Playful", but I still need
    one that clearly shows character distinctions. 
    With: Monaco, No 0 slash: Courier New, Lucida Console, Terminal*/
    /*font-family:  Monaco,monospace;*/
}

body {
/*    max-width: 900px;
    margin: 40px auto;*/
    /*font-family: monospace !important;*/
    font-size:14px;
    font-family:sans-serif;
    /*line-height:1.4;*/
}

/*https://css-tricks.com/simple-css-row-column-highlighting/*/
/*https://stackoverflow.com/questions/17119594*/
table {
/*	overflow-y: hidden;
	overflow-x: auto;*/
	/*width:100%;*/
	/*display: block;*/
	overflow:hidden;
	/*  border:2px solid #ccc;*/
	border:solid #ccc; 
	border-width: 1px 2px 2px 1px; /*To deal with hidden border*/
	/*outline:1px solid #ccc;*/
	border-collapse: collapse;
}
/*table tr:nth-child(even) {
    background-color:lightgray;
}*/
/*table th {*/
th {
	background-color:#f2f2f2;
	border:1px solid #ccc;
	/*padding:3px 3px;*/
	padding: 1px 6px; 
	text-align: left;
	font-weight: bold;
}
hr {
	background-color: #ddd; 
	height: 1px; 
	/*border: 0;*/
}
table tr {
	border:1px solid #ccc;
}
tr:hover {
  background-color: #f2f2f2;;
}
td, th {
  position: relative;
}
td:hover::after,
th:hover::after {
  content: "";
  position: absolute;
  background-color: #f2f2f2;;
  left: 0;
  top: -5000px;
  height: 10000px;
  width: 100%;
  z-index: -1;
}

input {
	font-family: Monaco, monospace;
	margin: 5px 2px;
}
h3 {
	border-bottom: 1px solid #ddd;
	margin-bottom: 0.75em;
	margin-top: 1.5em;
}
.wrapper {
/*	width:700px;*/
	margin: 40px auto;
	max-width:725px;
	/*margin:50px 0px;*/
	text-align:center;
}
.center {
	display:inline-block;
}
#input {
	text-align:left;
	margin: 12px auto;
	line-height:1.6;
}
#output {
	text-align:left;
	margin: 12px auto;
	line-height:1.6;
}

.grid { 
	/*margin:1em auto;*/ 
	/*border-collapse: collapse;*/
	font-family:  Monaco, monospace;
}
.grid td {
    cursor:pointer;
    width:23px; height:20px;  /*30, 30*/
    border:1px solid #ccc;
    text-align:center;
    /*padding:3px;*/
    /*font-family:sans-serif; */
    font-size:12px; /*13px*/
}
.grid td.clicked {
    background-color:#ACCEF7;  /*yellow lightblue*/
    font-weight:bold; 
    /*color:red;*/
}


/*table settings incorporated above*/
/*table th { font-weight: bold; }*/
/*table td, table th*/
/*table th { padding: 1px 6px; text-align: left;}*/

/* Mobile */
/*@media only screen and (max-width: 767px) {
	
	table.responsive { margin-bottom: 0; }
	
	.pinned { position: absolute; left: 0; top: 0; background: #fff; width: 35%; overflow: hidden; overflow-x: scroll; border-right: 1px solid #ccc; border-left: 1px solid #ccc; }
	.pinned table { border-right: none; border-left: none; width: 100%; }
	.pinned table th, .pinned table td { white-space: nowrap; }
	.pinned td:last-child { border-bottom: 0; }
	
	div.table-wrapper { position: relative; margin-bottom: 20px; overflow: hidden; border-right: 1px solid #ccc; }
	div.table-wrapper div.scrollable table { margin-left: 35%; }
	div.table-wrapper div.scrollable { overflow: scroll; overflow-y: hidden; }	
	
	table.responsive td, table.responsive th { position: relative; white-space: nowrap; overflow: hidden; }
	table.responsive th:first-child, table.responsive td:first-child, table.responsive td:first-child, table.responsive.pinned td { display: none; }
	
}*/

/*#input {margin:1em auto;}*/
</style>


<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/seedrandom.min.js"></script> -->
<script src="./seedrandom.js"></script>

<!--experiment with d3-->
<!-- <script src="./d3.v4.js"></script> -->


</head>

<body>


<div class="wrapper">
	<h1>Tabula</h1>
<div class="center">
	<div id='input'>
		<h3>Master Password</h3>
		<p>Click <code>create</code> to generate a unique table of characters based on your master password.</p>
		Master: <input id="seed" type="password" size="70" value="CorrectHorseBatteryStaple"/>
		<input type="checkbox" onclick="toggleSe();">Show
		<input id="click" type="button" value="Create" onclick="populateGrid();"/>  <!--d3test();-->
		<button onclick="clearAll();">Clear</button> 
		<h3>Options</h3>
		<p> Next, set the options for the pattern that is followed when creating your password.  Select <code>manual</code> if you'd like to choose characters based on your own pattern.  Next, click a memorable starting cell to generate a password.</p>
		Method:
		<select id="method" onchange="renderDirections();" onfocus="this.selectedIndex = -1;">
				<option value="manual" selected="selected">Manual</option>
				<option value="line">Line</option>
				<option value="step">Step</option>
				<option value="spiral">Spiral</option>
		</select>
		<div id='dir'>
		</div>
		Length: <input id="length" type="text" size="3" value="16"/> <br>
	<h3>Tabula</h3>
	</div>
	<div id="tabula"></div>

	<div id="output">
		<h3>Results</h3>
<!-- 		<strong>Results</strong>
		<hr> -->
		Output: <input type="password" size="70" value="" id="password">
		<input type="checkbox" onclick="togglePs();">Show 
		<button onclick="copyPs()">Copy</button> 
		<button onclick="clearPs();">Clear</button> <br>
		<h3>Directions</h3>
<!-- 		<strong>Directions</strong>
		<hr> -->
		<p><ol>  <!-- This will create the same grid of characters that is unique to your password anytime, whatever computer you're on. -->
			<!-- <li>Create a grid by entering your unique Master Password and clicking <code>create</code> above.</li> -->
			<li>Enter your unique master password and click <code>create</code> above.  This creates a grid of characters that is unique to your password.  This same grid will show up whenever you enter your master password in the future, on any device.</li>
			<li>Set the desired <code>options</code>, choosing to either manually select cells or automate the process with a pattern.</li>
			<li>Choose a starting cell based on something memorable about the intended site.  For example, maybe your <strong>A</strong>mazo<strong>N</strong>.com password would start at the <code><strong>[A,N]</strong></code> grid location.  Click this cell to begin. </li>
			<li>In the future, remember your master password and your site-based technique, and you can generate any password you need without storing it anywhere!</li>
		</ol></p>
	</div>
	<!-- <input type="password" name="password" id="myPassword" size="70" /> -->
	<!-- <img src="theicon" onmouseover="mouseoverPass();" onmouseout="mouseoutPass();" /> -->
</div>
</div>


<!-- source: https://stackoverflow.com/questions/9140101,  http://jsfiddle.net/6qkdP/2/ -->
<script>

var passchars = {
	V: "AEIOU",
	C: "BCDFGHJKLMNPQRSTVWXYZ",
	v: "aeiou",
	c: "bcdfghjklmnpqrstvwxyz",
	A: "AEIOUBCDFGHJKLMNPQRSTVWXYZ",
	a: "AEIOUaeiouBCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz",
	n: "0123456789",
	o: "@&%?,=[]_:-+*$#!'^~;()/.",
	x: "AEIOUaeiouBCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz0123456789!@#$%^&*()",
	" ": " "
};

//Initial settings
var st = {
	'rows': 26,  //Either this, or zero index rows/columns
	'cols': 26,
	'charSet': 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789[]{}:;>~!@#$%^&*()+=-?<', //Get from form eventually?
	'blankList': generateCharacters(26,26,' '),
	'charList': []
};

//Initialize values, build empty grid
var rows = 26;
var cols = 26;
var charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789[]{}:;>~!@#$%^&*()+=-?<';
var emptyChars = ' '
//var charList = generateCharacters(rows,cols,emptyChars);

appendGrid(st.blankList);


//DONE: pull the character generating process out & put them in a data
// structure so they can be iterated over.  List of list?
//TODO: figure out how to create responsive tables for mobile. . . if you just
//go with distributing the HTML page as the cross platform idea
//https://zurb.com/playground/playground/responsive-tables/index.html
//downloaded as responsive-tables.js/.css
//swipe demo is cool here too: https://github.com/filamentgroup/tablesaw
//TODO: Finalize charset, because changing that will change the output
//of all grids generated with the charSet
//TODO: charaset dropdown selector?  


function renderDirections() {
    var meth = document.getElementById('method');
    var method = meth.options[meth.selectedIndex].value;

    var dir = document.getElementById('dir');

	var options = {
		'cardinal': ['N', 'S', 'E', 'W'],
		'angle': ['NE', 'NW', 'SE', 'SW']
	}

	if (method === 'line') {
		var sel = document.createElement('select');
		sel.id = 'direction';
		var opts = options.cardinal.concat(options.angle);
		opts.forEach(function(opt) {
			var el = document.createElement('option');
			el.value = opt;
			el.textContent = opt;
			sel.appendChild(el);
		});
		dir.innerHTML = 'Direction: ' + sel.outerHTML
	} else if (method === 'step') {
		var sel = document.createElement('select');
		sel.id = 'direction';
		var opts = options.angle;
		opts.forEach(function(opt) {
			var el = document.createElement('option');
			el.value = opt;
			el.textContent = opt;
			sel.appendChild(el);
		});
		dir.innerHTML = 'Direction: ' + sel.outerHTML;
	} else {
		dir.innerHTML = '';
	}
	//Otherwise, do nothing.  
}




function generateHeader(alpha) {
	//console.log(alpha);
    var header = document.createElement('thead');
    var hrow = document.createElement('tr');
    hrow.appendChild(document.createElement('th'));
    for (var j=0; j<alpha.length; j++) {
    	var th = document.createElement('th');
    	th.innerHTML = alpha[j];
    	hrow.appendChild(th);
    }
    header.appendChild(hrow);
    //console.log(header);
    return header;
}


//source: https://stackoverflow.com/questions/9140101,
// http://jsfiddle.net/6qkdP/2/   
//buildGrid instead   
function buildGrid(rows, cols, charList, callback){
    var i=0;
    var grid = document.createElement('table');
    grid.className = 'grid responsive';  //Add responsive class

    var alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    var header = generateHeader(alpha);
    grid.appendChild(header);
    
    for (var r=0; r<rows; ++r){
        var tr = grid.appendChild(document.createElement('tr'));
        var rowList = charList[r];

        //Add the row alphabet header
        var h = document.createElement('th');
        h.innerHTML = alpha[r];
        tr.appendChild(h);

        for (var c=0; c<cols; ++c){
            var cell = tr.appendChild(document.createElement('td'));
            //cell.innerHTML = ++i;
            ++i;
            //var str = randomString(1);
            var str = rowList[c];
            cell.innerHTML = str;
            cell.id = 'c' + String(c) +','+ String(r);  //x, y, where y is "negative"
            //cell.innerHTML = ' ';  //Just build an empty one, then append data, event listener later?
            //why not just bind these variables, rather than the convoluted encapsulation?
            cell.addEventListener('click',(function(el,r,c,i,str){
                return function(){
                    callback(el,r,c,i,str);
                }
            })(cell,r,c,i,str),false);
        }
    }
    return grid;
}

function clicked(el,row,col,i,str) {

    var meth = document.getElementById('method');
    var method = meth.options[meth.selectedIndex].value;
    var len = document.getElementById('length');
    var length = Number(len.value);

	switch(method) {
		case 'manual':
		    var ps = document.getElementById('password');
		    ps.value = ps.value += el.textContent;
		    el.className='clicked';
		    break;
		case 'line':
	    	var dir = document.getElementById('direction');
	    	var direction = dir.options[dir.selectedIndex].value;
			return highlightPs(lineMatrix(col,row,direction,length));
			break;
		case 'step':
	    	var dir = document.getElementById('direction');
	    	var direction = dir.options[dir.selectedIndex].value;
			return highlightPs(stepMatrix(col,row,direction,length));
			break;
		case 'spiral':
			return highlightPs(spiralMatrix(col,row,length));
			break;

	}
}


//Todo: maybe call appendGrid, or addGrid()
//and call the clickableGrid buildGrid instead, more descriptive.  
function appendGrid(charList) {

	//Reset pw
	document.getElementById('password').value = '';

	//var lastClicked; //Not needed currently
	var grid = buildGrid(st.rows, st.cols, charList, clicked);
	var el = document.getElementById('tabula');
	el.innerHTML = '';
	el.appendChild(grid);
}



//ASCII Printable characters: https://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
//https://stackoverflow.com/questions/1349404
function randomString(len, charSet) {
    charSet = charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789[]{}:;>~!@#$%^&*()+=-?<';
    var randomString = '';
    for (var i = 0; i < len; i++) {
    	//Random here is the special seedrandom.js version
        var randomPos = Math.floor(Math.random() * charSet.length);
        randomString += charSet.substring(randomPos,randomPos+1);
    }
    return randomString;
}


function animateCell(cell, steps, duration) {
	function changeCell(timestamp, cell, steps, duration){
	    var timestamp = timestamp || new Date().getTime();
	    var runtime = timestamp - starttime;
	    var progress = runtime / duration;
	    progress = Math.min(progress, 1);
	    cell.textContent = String.fromCharCode(32+steps*progress);

	    if (runtime < duration){ // if duration not met yet
	    	// Call requestAnimationFrame again with parameters
	        requestAnimationFrame(function(timestamp){ 
	            changeCell(timestamp, cell, steps, duration);
	        });
	    }
	}
	//http://www.javascriptkit.com/javatutors/requestanimationframe.shtml
	var starttime;
	 
	requestAnimationFrame(function(timestamp){
		//if browser doesn't support requestAnimationFrame, 
		//generate our own timestamp using Date
	    starttime = timestamp || new Date().getTime(); 
	    changeCell(timestamp, cell, steps, duration);
	});
}


//https://stackoverflow.com/questions/5226285
function populateGrid() {

	clearPs();

	var charList = generateCharacters(rows,cols,st.charSet);
	st.charList = charList;
	var joinedList = charList.reduce(function(a, b){return a.concat(b);}, []);//[].concat(charList); //flatten

	var cells = Array.from(document.getElementsByTagName('td'));

	//Using requestAnimationFrame
	for (var i=0; i<cells.length; i++) {

		var num = 32;
		var endNum = joinedList[i].charCodeAt(0);
		var cell = cells[i];
		var steps = endNum - num;
		var duration = 750; 

		//https://stackoverflow.com/questions/45829536/requestanimationframecallback-with-for-loop-issue
		// (function(cell,steps,duration) {
		// 	animate(cell,steps,duration);
		// })(cell,steps,duration);
		// This function now is the closure:
		animateCell(cell,steps,duration);
	}

}

function generateCharacters(rows, cols, charset) {
	//Using seedrandom.js
	//https://github.com/davidbau/seedrandom
	//MIT License
	var seed = document.getElementById('seed').value;
	Math.seedrandom(seed);
	var charList = [];
	for (var i=0; i<cols; i++) {
		charList.push(randomString(26, charset).split(''));
	}
	//Set global.  
	//st.charList = charList;
	return charList
}


// //TODO: maybe just incorporate this into 'clicked function,
// // as the switch is redundant to that logic.  
// function generatePw(x,y,len,dir,method) {
// 	//len = how long, strategy = e.g. digonal NE, start=cell start.  
// 	//then write all the other functions outside
// 	// eventually a switch based on

// 	//dir won't be relevant to every function

// 	switch(method) {
// 		case 'line':
// 			return highlightPs(lineMatrix(x,y,dir,len));
// 			break;
// 		case 'spiral':
// 			return highlightPs(spiralMatrix(x,y,len));
// 			break;
// 		case 'step':
// 			return highlightPs(stepMatrix(x,y,dir,len));
// 			break;
// 	}

// }


function highlightPs(obj) {
	// console.log(pw);
	// console.log(ids);
	//console.log(obj);
	var ids = obj.ids;
	var pw = obj.pw;
	function changeClass(id) { 
		var el = document.getElementById(id);
		el.className = 'clicked';
	}

	for (var j=0; j<ids.length; j++) {
		var delay = 50;
		setTimeout(changeClass.bind(null, ids[j]), delay*j);  //delay*j
	}

	var el = document.getElementById('password');
	el.value = pw;
}

function handleDir(dir) {
	// Could be N, S, E, W, NE, NW, SE, SW
	// [x, y, where South = +y, East = +x 
	// for operating on an array of arrays
	var allDir = {
		'N': [0, -1], 'S': [0, 1], 'E':[1, 0], 'W':[-1, 0],
		'NE':[1, -1], 'NW':[-1, -1], 'SE':[1, 1], 'SW':[-1, 1]
	}

	return allDir[dir];

}



/* Grid Traversing Functions */


function lineMatrix(x, y, dir,len) {
	//var matrix = generateCharacters(st.rows,st.cols,charSet);
	var matrix = st.charList;
	var inc = handleDir(dir);
	//console.log(inc);
	//return;
	var xinc = inc[0];
	var yinc = inc[1];
	var pw = '';
	var ids = [];

	while (pw.length < len) {
		//console.log('entered while');
		//Putting this condition first prevents the edge node from 
		//being added before heading to handleEdge recursion. 

		//This should only activate if next will be out of bounds. 
		//Right now, if it's on top edge and going down, it shouldn't follow edge. 
		// You need to look ahead here to see if next move will violate edge.  if not, continue
		// The problem is that you need to check that its greather than, less than, AND that next step
		// will be out of bounds
		if ( (x === st.cols-1 && x + xinc > st.cols-1) || 
			 (x === 0 && x + xinc < 0) || 
			 (y === st.rows-1 && y + yinc > st.rows-1) || 
			 (y === 0 && y + yinc < 0)) {  
			 //So this works in SE, but not in NW.
		//if (x + xinc >= st.cols-1 || x + xinc <= 0 || y + yinc >= st.rows-1 || y + yinc <= 0) {
			//handleEdge(x,y,pw,ids,len,matrix,callback);
			//break; //Leave while loop
			//var res = handleEdge(x,y,pw,ids,len,matrix,callback);
			return handleEdge(x,y,pw,ids,len,matrix);
			//pw = res[0];
			//ids = res[1];
			//break;
		}
		pw += matrix[y][x];  //From top left, x is across, y works down on outer arrays
		ids.push('c' + String(x) + ',' + String(y))
		x += xinc;
		y += yinc;
		//console.log(pw);
		//console.log(pw.length);
		//callback(pw,ids);
	}
	//If recursion isn't entered:
	return {pw: pw, ids: ids};
}

function stepMatrix(x, y, dir, len) {
	var matrix = st.charList;
	var inc = handleDir(dir);
	//console.log(inc);
	//return;
	var xinc = inc[0];
	var yinc = inc[1];
	var pw = '';
	var ids = [];
	var across = true;

	while (pw.length < len) {

		//Recurse if hits edge
		if ((x === st.cols-1 && x + xinc > st.cols-1) || 
			(x === 0 && x + xinc < 0) || 
			(y === st.rows-1 && y + yinc > st.rows-1) || 
			(y === 0 && y + yinc < 0)) {  

			return handleEdge(x,y,pw,ids,len,matrix);
		}

		pw += matrix[y][x];  //From top left, x is across, y works down on outer arrays
		ids.push('c' + String(x) + ',' + String(y))

		if (across) {
			x += xinc;
			across = false;
		} else {
			y += yinc;
			across = true;
		}
		
		//console.log(pw);
		//console.log(pw.length);
		//callback(pw,ids);
	}
	//If recursion isn't entered:
	return {pw: pw, ids: ids};

}

function spiralMatrix(x,y,len) {

	var matrix = st.charList; //Global matrix
	var xinc = 1;
	var yinc = -1;
	var xlen = 1;
	var ylen = 1;
	var pw = '';
	var ids = [];
	var across = false;  //Start upwards

	while (pw.length < len) {
		// pw += matrix[y][x];  //From top left, x is across, y works down on outer arrays
		// ids.push('c' + String(x) + ',' + String(y))
		//Alternates [Up, Right], [Down, Left] adding 1 cell length each time
		if (across) {
			for (var i=0; i<xlen; i++) {
				//Recurse if on edge
				if ((x === st.cols-1 && x + xinc > st.cols-1) || 
					(x === 0 && x + xinc < 0) || 
					(y === st.rows-1 && y + yinc > st.rows-1) || 
					(y === 0 && y + yinc < 0)) {  

					return handleEdge(x,y,pw,ids,len,matrix);
				}
				pw += matrix[y][x];  //From top left, x is across, y works down on outer arrays
				ids.push('c' + String(x) + ',' + String(y));
				x += xinc; //Increment x by the current direction
			}
			xlen += 1;  //Increas arm length for next time
			xinc = -xinc;  //Switch sign of the increment
			//xlen = xlen < 0 ? (-1*xlen + 1) : (-1*(xlen + 1)); //Flips sign, gets one longer
			across = false;  //Move in y direction next
		} else {
			for (var i = 0; i<ylen; i++) {
				//Recurse if on edge
				if ((x === st.cols-1 && x + xinc > st.cols-1) || 
					(x === 0 && x + xinc < 0) || 
					(y === st.rows-1 && y + yinc > st.rows-1) || 
					(y === 0 && y + yinc < 0)) {  

					return handleEdge(x,y,pw,ids,len,matrix);
				}
				pw += matrix[y][x];  //From top left, x is across, y works down on outer arrays
				ids.push('c' + String(x) + ',' + String(y));
				y += yinc; //Increment x by the current direction
			}
			ylen += 1;  //Increas arm length for next time
			yinc = -yinc;  //Switch sign of the increment
			//xlen = xlen < 0 ? (-1*xlen + 1) : (-1*(xlen + 1)); //Flips sign, gets one longer
			across = true;  //Move in x direction next
		}
	}
	//If recursion isn't entered:
	return {pw: pw, ids: ids};

}


//Needs some work, developed on accident while
//making spiral.  Just needs a shift
//could also do galaxy style, where offsets in outward
//motion.  That would be too hard to re-create though,
//manually if it was needed.  
function starMatrix(x,y,len) {

	var matrix = st.charList; //Global matrix
	var xinc = 1;
	var yinc = -1;
	var pw = '';
	var ids = [];
	var across = false;  //Start upwards

	while (pw.length < len) {

		//Recurse if on edge
		if ((x === st.cols-1 && x + xinc > st.cols-1) || 
			(x === 0 && x + xinc < 0) || 
			(y === st.rows-1 && y + yinc > st.rows-1) || 
			(y === 0 && y + yinc < 0)) {  

			return handleEdge(x,y,pw,ids,len,matrix);
		}

		pw += matrix[y][x];  //From top left, x is across, y works down on outer arrays
		ids.push('c' + String(x) + ',' + String(y))

		//Alternates [Up, Right], [Down, Left] adding 1 cell length each time
		if (across) {

			// for (i<0; i<xinc; i++) {
			// 	pw += matri

			// }
			x += xinc;
			xinc = xinc < 0 ? (-1*xinc + 1) : (-1*(xinc + 1)); //Flips sign, gets one longer
			across = false;
		} else {
			y += yinc;
			yinc = yinc < 0 ? (-1*yinc + 1) : (-1*(yinc + 1));; //Flips sign, gets one longer
			across = true;
		}
		//console.log(pw);
		//console.log(pw.length);
	}
	//If recursion isn't entered:
	return {pw: pw, ids: ids};

}


function handleEdge(x, y, pw, ids, len, matrix, callback) {
	//Always moves clockwise when it hits an edge
	//This could function recursively as well
	if (pw.length === len) {
		//callback(pw, ids);
		//return [pw, ids];
		return {pw: pw, ids: ids};
	}

	//console.log('enter recurse');

	//https://stackoverflow.com/questions/33513358
	if (x === y) {  //You're at a SE, NW corner 
		pw += matrix[y][x];
		ids.push('c' + String(x) + ',' + String(y));
		if (x === 0) {
			return handleEdge(x+1, y, pw, ids, len, matrix); //Move right
		} else if (x === 25) {
			return handleEdge(x-1, y, pw, ids, len, matrix); //Move left
		}
	} else if (x >= st.cols-1) {  
		pw += matrix[y][x];
		ids.push('c' + String(x) + ',' + String(y));
		return handleEdge(x, y+1, pw, ids, len, matrix); //Move down
	} else if (x === 0) {
		pw += matrix[y][x];
		ids.push('c' + String(x) + ',' + String(y));
		return handleEdge(x, y-1, pw, ids, len, matrix); //Move up
	} else if (y >= st.cols-1) {
		pw += matrix[y][x];
		ids.push('c' + String(x) + ',' + String(y));
		return handleEdge(x-1, y, pw, ids, len, matrix); //Move left
	} else if (y === 0) {
		pw += matrix[y][x];
		ids.push('c' + String(x) + ',' + String(y));
		return handleEdge(x+1, y, pw, ids, len, matrix); //Move right
	}
}


/* Helper Functions */

function toggleSe() {
    var x = document.getElementById("seed");
    if (x.type === "password") {
        x.type = "text";
    } else {
        x.type = "password";
    }
}

function togglePs() {
    var x = document.getElementById("password");
    if (x.type === "password") {
        x.type = "text";
    } else {
        x.type = "password";
    }
}

function copyPs() {
	var x = document.getElementById("password");
	var open = false;
	if(x.type === 'password') {open=true; togglePs();}

	x.select();
	document.execCommand("Copy");
	if(open) {togglePs();}
}

function clearPs() {
    var ps = document.getElementById('password');
    ps.value = '';
    //Remove all highlighted classes
    //https://stackoverflow.com/questions/22754315
    var hls = Array.from(document.getElementsByClassName('clicked'));
    hls.map(function(el){el.className = '';});
}

function clearAll() {
	appendGrid(st.blankList);
	clearPs();
	var el = document.getElementById('seed');
	el.value = '';
}





//Is this good, or does it make it seem less fragile?  
//It's all for show. . . although not having to rebuild the html each
//time is nice.  
function d3test() {
	var charList = generateCharacters(rows,cols,charSet);
	var joinedList = charList.reduce(function(a, b){return a.concat(b);}, []);//[].concat(charList); //flatten
	//console.log(joinedList);
	var td = d3.selectAll('td')
		.data(joinedList)
		//.enter()
		//.append('td')
		.text(function(d) {return d;})
		.transition()
		.duration(1200)
		.ease(d3.easeLinear)
		.tween("text", function(d) {
			//https://stackoverflow.com/questions/45831942/tweening-numbers-in-d3-v4-not-working-anymore-like-in-v3
			var node = this;
			//var i = d3.interpolate(0, joinedList.length);
			var i = d3.interpolate(33, d.charCodeAt(0));
			//var i = d3.interpolate(0, 100);
			//console.log(i(0.5));
			return function(t) {
				//d3.select(this).text(joinedList[i(t)]);
				//d3.select(node).text(String.fromCharCode(Math.round(i(t))));
				d3.select(node).text(String.fromCharCode(i(t)));
			};
		});
		
		//https://bl.ocks.org/bricedev/a0c5ef180272fac3aea6
		//https://github.com/d3/d3-interpolate
		//https://github.com/d3/d3-interpolate#interpolateString
}


/*Code for responsive tables*/
/*source: https://zurb.com/playground/projects/responsive-tables/index.html */
/*modified to remove jQuery */

//$(document).ready(function() {
//https://stackoverflow.com/questions/799981
// document.addEventListener("DOMContentLoaded", function(event) { 
  
//     var switched = false;
//     var updateTables = function() {
//         if ((window.innerWidth < 767) && !switched) {
//             switched = true;
//             document.getElementsByClassName("responsive").each(function(i, element) {
//                 splitTable(element);
//             });
//             return true;
//         } else if (switched && (window.innerWidth > 767)) {
//             switched = false;
//             document.getElementsByClassName("responsive").each(function(i, element) {
//                 unsplitTable($(element));
//             });
//         }
//     };
//     // $(window).load(updateTables);
//     // $(window).bind("resize", updateTables);
//     window.onload(updateTables);
//     window.bind("resize", updateTables);

//     function splitTable(original) {
//     	//original.wrap("<div class='table-wrapper' />");
//     	//https://stackoverflow.com/questions/6838104
// 		org_html = original.innerHTML;
// 		new_html = "<div class='table-wrapper' />" + org_html + "</div>";
// 		original.innerHTML = new_html;

//         //var copy = original.clone();
//         var copy = original.cloneNode(true);

//         copy.find("td:not(:first-child), th:not(:first-child)").css("display", "none");
//         copy.querySelector("td:not(:first-child), th:not(:first-child)") !== null

//         copy.removeClass("responsive");
//         original.closest(".table-wrapper").append(copy);
//         copy.wrap("<div class='pinned' />");
//         original.wrap("<div class='scrollable' />");
//     }

//     function unsplitTable(original) {
//         original.closest(".table-wrapper").find(".pinned").remove();
//         original.unwrap();
//         original.unwrap();
//     }
// });



</script>

</body>
</html>