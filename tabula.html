
<!doctype html>
<head>
<style>

* {
/*    max-width: 900px;
    margin: 40px auto;*/
    font-family: monospace;
}

body {
/*    max-width: 900px;
    margin: 40px auto;*/
    /*font-family: monospace !important;*/
}

/*https://css-tricks.com/simple-css-row-column-highlighting/*/
table {
  overflow: hidden;
  border:1px solid #ccc;
}

tr:hover {
  background-color: #f2f2f2;;
}
td, th {
  position: relative;
}
td:hover::after,
th:hover::after {
  content: "";
  position: absolute;
  background-color: #f2f2f2;;
  left: 0;
  top: -5000px;
  height: 10000px;
  width: 100%;
  z-index: -1;
}


/*table tr:nth-child(even) {
    background-color:lightgray;
}*/
table tr {
	border:1px solid #ccc;
}
table tr:nth-child(odd) {
    /*background-color:#f2f2f2;*/
}
table th {
	background-color:#f2f2f2;
	border:1px solid #ccc;
}
.wrapper {
/*	width:700px;*/
	/*margin: 40px auto;*/
	margin:50px 0px;
	text-align:center;
}
.center {
	display:inline-block;
}
#input {
	text-align:left;
}
#output {
	text-align:left;
}

.grid { /*margin:1em auto;*/ border-collapse:collapse }
.grid td {
    cursor:pointer;
    width:20px; height:20px;  /*30, 30*/
    border:1px solid #ccc;
    text-align:center;
    /*font-family:sans-serif; */
    font-size:13px
}
.grid td.clicked {
    background-color:yellow;
    font-weight:bold; color:red;
}
/*#input {margin:1em auto;}*/
</style>


<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/seedrandom.min.js"></script> -->
<script src="./seedrandom.js"></script>

<!--experiment with d3-->
<script src="./d3.v4.js"></script>


</head>

<body>


<div class="wrapper">
<div class="center">
	<div id='input'>
		<!-- Should the master be password protected too?-->
		Master: <input id="seed" type="text" size="70" value="CorrectHorseBatteryStaple"/>
		<input id="click" type="button" value="Create" onclick="d3test();"/>
		<button onclick="clearAll();">Clear</button> 
		<!-- <input id="click" type="button" value="Create" onclick="fillGrid();"/> --> <br>
	</div>

	<div id="tabula"></div>

	<div id="output">
		Output: <input type="password" size="70" value="" id="password">
		<button onclick="copyPs()">Copy</button> 
		<button onclick="clearPs();">Clear</button> <br>
		<input type="checkbox" onclick="togglePs();">Show Password 
	</div>
	<!-- <input type="password" name="password" id="myPassword" size="70" /> -->
	<!-- <img src="theicon" onmouseover="mouseoverPass();" onmouseout="mouseoutPass();" /> -->
</div>
</div>


<!-- source: https://stackoverflow.com/questions/9140101,  http://jsfiddle.net/6qkdP/2/ -->
<script>


// var seed = document.getElementById('seed').value;
// Math.seedrandom(seed);
// // var src = Math.random();
// // var src2 = Math.random();
// // console.log(src, src2);
// var all = [];

// var lastClicked;
// var grid = clickableGrid(26,26,function(el,row,col,i){
//     // console.log("You clicked on element:",el);
//     // console.log("You clicked on row:",row);
//     // console.log("You clicked on col:",col);
//     // console.log("You clicked on item #:",i);
//     el.className='clicked';
//     if (lastClicked) lastClicked.className='';
//     lastClicked = el;
// });

// document.body.appendChild(grid);

function generateHeader(alpha) {
	//console.log(alpha);
    var header = document.createElement('thead');
    var hrow = document.createElement('tr');
    hrow.appendChild(document.createElement('th'));
    for (var j=0; j<alpha.length; j++) {
    	var th = document.createElement('th');
    	th.innerHTML = alpha[j];
    	hrow.appendChild(th);
    }
    header.appendChild(hrow);
    //console.log(header);
    return header;
}



//source: https://stackoverflow.com/questions/9140101,
// http://jsfiddle.net/6qkdP/2/      
function clickableGrid(rows, cols, charList, callback){
    var i=0;
    var grid = document.createElement('table');
    grid.className = 'grid';

    var alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    var header = generateHeader(alpha);
    grid.appendChild(header);
    
    for (var r=0; r<rows; ++r){
        var tr = grid.appendChild(document.createElement('tr'));
        var rowList = charList[r];

        //Add the row alphabet header
        var h = document.createElement('th');
        h.innerHTML = alpha[r];
        tr.appendChild(h);

        for (var c=0; c<cols; ++c){
            var cell = tr.appendChild(document.createElement('td'));
            //cell.innerHTML = ++i;
            ++i;
            //var str = randomString(1);
            var str = rowList[c];
            cell.innerHTML = str;
            cell.id = 'c' + String(c) +','+ String(r);  //x, y, where y is "negative"
            //cell.innerHTML = ' ';  //Just build an empty one, then append data, event listener later?
            //why not just bind these variables, rather than the convoluted encapsulation?
            cell.addEventListener('click',(function(el,r,c,i,str){
                return function(){
                    callback(el,r,c,i,str);
                }
            })(cell,r,c,i,str),false);
        }
    }
    return grid;
}

//Todo: insert white space in grid to begin with
//generate all characters, then use d3 transition to transition 
//from A or something else to final character
// &nbsp; to begin with?



function generateCharacters(rows, cols, charset) {
	//Using seedrandom.js
	//https://github.com/davidbau/seedrandom
	//MIT License
	var seed = document.getElementById('seed').value;
	Math.seedrandom(seed);
	var charList = [];
	for (var i=0; i<cols; i++) {
		charList.push(randomString(26, charset).split(''));
	}
	return charList
}


//Todo: maybe call appendGrid,
//and call the clickableGrid buildGrid instead, more descriptive.  
function buildGrid(charList) {

	document.getElementById('password').value = '';

	//Using seedrandom.js
	//https://github.com/davidbau/seedrandom
	//MIT License
	// var seed = document.getElementById('seed').value;
	// Math.seedrandom(seed);
	// var src = Math.random();
	// var src2 = Math.random();
	// console.log(src, src2);
	//var all = [];

	// var rows = 26;
	// var cols = 26;
	// var charList = [];
	// for (var i=0; i<cols; i++) {
	// 	charList.push(randomString(26).split(''));
	// }
	//console.log(charList);
	//return;


	function clicked(el,row,col,i,str) {
	    // console.log("You clicked on element:",el);
	    // console.log("You clicked on row:",row);
	    // console.log("You clicked on col:",col);
	    // console.log("You clicked on item #:",i);
	    el.className='clicked';

	    //Uncomment to remove coloring of all but current click:
	    // if (lastClicked) lastClicked.className='';
	    // lastClicked = el;

	    var ps = document.getElementById('password');
	    // console.log(ps.value);
	    // console.log(i);

	    //ps.value = ps.value += str;
	    ps.value = ps.value += el.textContent;

	    //Todo: this is where you can follow predefined patters
	    //call a function like followPattern(row,col,i,str); that grabs the 
	    //pattern from a form and follows, if not 'none'

	}

	//var lastClicked; //Not needed currently
	var grid = clickableGrid(rows, cols, charList, clicked);

	/*
		function(el,row,col,i,str){
	    // console.log("You clicked on element:",el);
	    // console.log("You clicked on row:",row);
	    // console.log("You clicked on col:",col);
	    // console.log("You clicked on item #:",i);
	    el.className='clicked';

	    //Uncomment to remove coloring of all but current click:
	    // if (lastClicked) lastClicked.className='';
	    // lastClicked = el;

	    var ps = document.getElementById('password');
	    // console.log(ps.value);
	    // console.log(i);
	    ps.value = ps.value += str;

	}); */

	//console.log(grid);
	//console.log(typeof grid);

	var el = document.getElementById('tabula');
	el.innerHTML = '';
	el.appendChild(grid);

}

function fillGrid() {
	var charList = generateCharacters(rows,cols,charSet);
	buildGrid(charList);
}


//ASCII Printable characters: https://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
//https://stackoverflow.com/questions/1349404
function randomString(len, charSet) {
    charSet = charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789[]{}:;>~!@#$%^&*()+=-?<';
    var randomString = '';
    for (var i = 0; i < len; i++) {
    	//Random here is the special seedrandom.js version
        var randomPos = Math.floor(Math.random() * charSet.length);
        randomString += charSet.substring(randomPos,randomPos+1);
    }
    return randomString;
}

function togglePs() {
    var x = document.getElementById("password");
    if (x.type === "password") {
        x.type = "text";
    } else {
        x.type = "password";
    }
}

function copyPs() {
	var x = document.getElementById("password");
	var open = false;
	if(x.type === 'password') {open=true; togglePs();}

	x.select();
	document.execCommand("Copy");
	if(open) {togglePs();}
}

function clearPs() {
    var ps = document.getElementById('password');
    ps.value = '';
    //Remove all highlighted classes
    //https://stackoverflow.com/questions/22754315
    var hls = Array.from(document.getElementsByClassName('clicked'));
    hls.map(function(el){el.className = '';});
}

function clearAll() {
	buildGrid(st.blankList);
	clearPs();
	var el = document.getElementById('seed');
	el.value = '';
}

//Is this good, or does it make it seem less fragile?  
//It's all for show. . . although not having to rebuild the html each
//time is nice.  
function d3test() {
	var charList = generateCharacters(rows,cols,charSet);
	var joinedList = charList.reduce(function(a, b){return a.concat(b);}, []);//[].concat(charList); //flatten
	//console.log(joinedList);
	var td = d3.selectAll('td')
		.data(joinedList)
		//.enter()
		//.append('td')
		.text(function(d) {return d;})
		.transition()
		.duration(1200)
		.ease(d3.easeLinear)
		.tween("text", function(d) {
			//https://stackoverflow.com/questions/45831942/tweening-numbers-in-d3-v4-not-working-anymore-like-in-v3
			var node = this;
			//var i = d3.interpolate(0, joinedList.length);
			var i = d3.interpolate(33, d.charCodeAt(0));
			//var i = d3.interpolate(0, 100);
			//console.log(i(0.5));
			return function(t) {
				//d3.select(this).text(joinedList[i(t)]);
				//d3.select(node).text(String.fromCharCode(Math.round(i(t))));
				d3.select(node).text(String.fromCharCode(i(t)));
			};
		});
		
		//https://bl.ocks.org/bricedev/a0c5ef180272fac3aea6
		//https://github.com/d3/d3-interpolate
		//https://github.com/d3/d3-interpolate#interpolateString
}


/*
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function processArray(items, process) {
    var todo = items.concat();

    setTimeout(function() {
        process(todo.shift());
        if(todo.length > 0) {
            setTimeout(arguments.callee, 25);
        }
    }, 25);
}


async function each(items, fn) {

    if (items && items.length) {
      await Promise.all(
        items.map(async function(item, i, arr) { await fn(item, i, arr); }));
    }
};
*/

//async function cycleChars()
//https://stackoverflow.com/questions/5226285
function cycleChars() {
	var charList = generateCharacters(rows,cols,charSet);
	var joinedList = charList.reduce(function(a, b){return a.concat(b);}, []);//[].concat(charList); //flatten

	var cells = Array.from(document.getElementsByTagName('td'));
	//console.log(cells);

	// cells.forEach(function(cell, i) {
	// 	var num = 32;
	// 	var endNum = joinedList[i].charCodeAt(0);

	// 	/* Other attempt at sleep*/
	// 	var steps = endNum - num;
	// 	var delay = 1; //1000/steps;
	// 	//console.log(steps);
		
	// 	async function changeContent(node, j) {  //node, j
	// 		//node.innerHTML = String.fromCharCode(num+j);
	// 		node.innerHTML = String.fromCharCode(num+j);
	// 	}

	// 	function doSetTimeout(j, cell, delay) {
	// 		//setTimeout(function(j) {cell.innerHTML = String.fromCharCode(num+j);}, delay*j);
	// 		setTimeout(function(j) {cell.innerHTML = String.fromCharCode(num+j);}, delay); //delay*j
	// 	}

	// 	//Can't quite get this working yet, not sure why.
	// 	//This is why: https://stackoverflow.com/questions/5226285 
	// 	for (var j=0; j<steps; j++) {
	// 		//node = cell;
	// 		//setTimeout(function(j) {cell.innerHTML = String.fromCharCode(num+j);}, delay*j);
	// 		//setTimeout(changeContent.bind(cell, j), delay*j);
	// 		//Works, with this, why?
	// 		setTimeout(changeContent.bind(null, cell, j), delay*j);  //delay*j
	// 		//doSetTimeout(j, cell, delay);
	// 	}

	// 	//Creates unique function for each, calls immediately
	// 	//async function()
	// 	// (async function(){
	// 	// 	while(num <= endNum) {
	// 	// 		cell.innerHTML = String.fromCharCode(num);
	// 	// 		num +=1;
	// 	// 		//sleep(10);
	// 	// 	}
	// 	// })();
	// });

	//Trying for loop
	// for (var i=0; i<cells.length; i++) {
	// //trying async:
	// //Works, but they are still executed sequentially. . .
	// //await each(cells, function(cell, i, arr) {
	// 	var num = 32;
	// 	var endNum = joinedList[i].charCodeAt(0);
	// 	var cell = cells[i];

	// 	/* Other attempt at sleep*/
	// 	var steps = endNum - num;
	// 	var delay = 100; //1000/steps;
	// 	//console.log(steps);
		
	// 	function changeContent(node, j) {  //node, j
	// 		//node.innerHTML = String.fromCharCode(num+j);
	// 		//node.innerHTML = String.fromCharCode(num+j);
	// 		node.textContent = String.fromCharCode(num+j);
	// 		//console.log(node);
	// 		//setTimeout(function(node,j){ node.textContent = String.fromCharCode(num+j)}, delay*j);
	// 	}

	// 	function doSetTimeout(j, cell, delay) {
	// 		//setTimeout(function(j) {cell.innerHTML = String.fromCharCode(num+j);}, delay*j);
	// 		setTimeout(function(j) {cell.innerHTML = String.fromCharCode(num+j);}, delay); //delay*j
	// 	}

	// 	//Can't quite get this working yet, not sure why.
	// 	//This is why: https://stackoverflow.com/questions/5226285 
	// 	for (var j=0; j<steps; j++) {
	// 		//node = cell;
	// 		//setTimeout(function(j) {cell.innerHTML = String.fromCharCode(num+j);}, delay*j);
	// 		//setTimeout(changeContent.bind(cell, j), delay*j);
	// 		//Works, with this, why?
	// 		(function(cell,j,delay) {
	// 			//setTimeout(function(cell,j,num){cell.textContent = String.fromCharCode(num+j);}, delay*j);
	// 			setTimeout(changeContent.bind(null,cell,j), delay);
	// 		})(cell,j,delay,num);

	// 		//setTimeout(changeContent.bind(null, cell, j), delay*j);  //delay*j
	// 		//changeContent(cells[i],j);
	// 		//doSetTimeout(j, cell, delay);
	// 	}
	// };  //);


	//Trying two for loops, that will access each cell
	//This kinda works, but not really.  
	// var time = 100;
	// var periods = 5;
	// var charNum = 32;

	// function changeCell(cell,cellChar) {
	// 	cell.innerHTML = cellChar;
	// };

	// for (var p=1; p<=periods; p++) {
	// 	//charNum += 1;
	// 	//setTimeout(function () {
	// 		for (var i=0; i<cells.length; i++) {
	// 			var cell = cells[i];
	// 			var endNum = joinedList[i].charCodeAt(0);
	// 			//console.log(endNum);
	// 			var currentNum = 32 + p*(endNum-32)/periods;
	// 			var cellChar = String.fromCharCode(currentNum);

	// 			// if (currentNum > endNum) {
	// 			// 	var cellChar = String.fromCharCode(endNum);
	// 			// }else {
	// 			// 	var cellChar = String.fromCharCode(currentNum);
	// 			// }
	// 			//cell.innerHTML = cellChar;

	// 			setTimeout(changeCell.bind(null,cell,cellChar), 0.000001*i);  //p*0.01
	// 		}
	// 	//}, 1000);
	// }

	//Using requestAnimationFrame
	for (var i=0; i<cells.length; i++) {

		//if (i<10) (console.log(i));

		var num = 32;
		var endNum = joinedList[i].charCodeAt(0);
		var cell = cells[i];

		/* Other attempt at sleep*/
		var steps = endNum - num;
		var duration = 800; //1000/steps;

		//https://stackoverflow.com/questions/45829536/requestanimationframecallback-with-for-loop-issue
		(function(cell,steps,time) {

			function changeCell(timestamp, cell, steps, duration){
			    //if browser doesn't support requestAnimationFrame, generate our own timestamp using Date:
			    var timestamp = timestamp || new Date().getTime();
			    var runtime = timestamp - starttime;
			    var progress = runtime / duration;
			    progress = Math.min(progress, 1);
			    //el.style.left = (dist * progress).toFixed(2) + 'px'
			    cell.textContent = String.fromCharCode(32+steps*progress);

			    if (runtime < duration){ // if duration not met yet
			        requestAnimationFrame(function(timestamp){ // call requestAnimationFrame again with parameters
			            changeCell(timestamp, cell, steps, duration);
			        });
			    }
			}
			//http://www.javascriptkit.com/javatutors/requestanimationframe.shtml
			var starttime;
			 
			requestAnimationFrame(function(timestamp){
			    starttime = timestamp || new Date().getTime(); //if browser doesn't support requestAnimationFrame, generate our own timestamp using Date
			    changeCell(timestamp, cell, steps, duration); // 400px over 1 second
			});
		})(cell,steps,duration);
	}


	// function start(period){
	//   if(period < 100){
	//     setTimeout(function(){
	//       period++;
	//       console.log(period);
	//       start(period);
	//     }, 1);
	//   }
	// }

}
// function start(period){
//   if(period < 100){
//     setTimeout(function(){
//       period++;
//       console.log(period);
//       start(period);
//     }, 0.01);
//   }
// }

// counter = 0;
// speed = 100

// setInterval(function () {
//   counter++;
//   console.log(counter);
// }, speed)




function generatePw(len,strategy,start) {
	//len = how long, strategy = e.g. digonal NE, start=cell start.  
	//then write all the other functions outside

	//or can you 

}

function handleDir(dir) {

	// Could be N, S, E, W, NE, NW, SE, SW
	// [x, y, where South = +y, East = +x 
	// for operating on an array of arrays
	var allDir = {
		'N': [0, -1], 'S': [0, 1], 'E':[1, 0], 'W':[-1, 0],
		'NE':[1, -1], 'NW':[-1, -1], 'SE':[1, 1], 'SW':[-1, 1]
	}

	return allDir[dir];

}

//Add to event handler a global setting based on form:
//if technique === 'manual', just append selection,
//otherwise, call function for the form setting, e.g. diagonal('NE');

//Actually, just name this line, then restrict
//the directions that can be passed in for diagonal
function lineMatrix(x, y, dir,len) {
	var matrix = generateCharacters(st.rows,st.cols,charSet);

	//var len = 12
	//var x = 12;  //Get these from click, 
	//var y = 12;
	//In form, only allow NE, SE, NW, SW for diagonal
	//var dir = 'NE';
	var inc = handleDir(dir);
	var xinc = inc[0];
	var yinc = inc[1];
	var pw = '';
	var ids = [];

	while (pw.length <= len) {
		//Putting this condition first prevents the edge node from 
		//being added before heading to handleEdge recursion. 

		//This should only activate if next will be out of bounds. 
		//Right now, if it's on top edge and going down, it shouldn't follow edge. 
		if (x >= st.cols-1 || x <= 0 || y >= st.rows-1 || y<=0) {
			handleEdge(x,y,pw,ids,len,matrix,callback);
			break; //Leave while loop
		}
		pw += matrix[y][x]  //From top left, x is across, y works down on outer arrays
		ids.push('c' + String(x) + ',' + String(y))
		x += xinc;
		y += yinc;
		console.log(pw);

	}
	function callback(pw, ids) {
		console.log(pw.length)
		console.log(pw);  //This logs actual pw
		console.log(ids);
		// ids.forEach(function(id) {
		// 	var el = document.getElementById(id);
		// 	el.className = 'clicked';
		// });

		function changeClass(id) {  //node, j
			var el = document.getElementById(id);
			el.className = 'clicked';
		}

		for (var j=0; j<ids.length; j++) {
			//node = cell;
			//setTimeout(function(j) {cell.innerHTML = String.fromCharCode(num+j);}, delay*j);
			//setTimeout(changeContent.bind(cell, j), delay*j);
			//Works, with this, why?
			var delay = 50;
			setTimeout(changeClass.bind(null, ids[j]), delay*j);  //delay*j
			//doSetTimeout(j, cell, delay);
		}
		//console.log(i);
		// d3.selectAll('td')
		// 	.filter(function(d) {console.log(d.id); return ids.indexOf(d.id) >= 0;})
		// 	.attr('class', 'clicked')
		// 	.transition()  //.duration(2000);
		// 	.duration(function(d) {return ids.indexOf(d.id);});

		var el = document.getElementById('password');
		el.value = pw;
	}
	//console.log(pw);  //This logs undefined because recursion hasn't completed yet. 
}

function handleEdge(x, y, pw, ids, len, matrix, callback) {
	//Always moves clockwise when it hits an edge
	//This could function recursively as well
	if (pw.length === len) {
		callback(pw, ids);
		return;
	}

	if (x === y) {  //You're at a SE, NW corner 
		pw += matrix[y][x];
		ids.push('c' + String(x) + ',' + String(y));
		console.log(pw);
		if (x === 0) {
			handleEdge(x+1, y, pw, ids, len, matrix, callback); //Move right
		} else {
			handleEdge(x-1, y, pw, ids, len, matrix, callback); //Move left
		}
	} else if (x >= st.cols-1) {  
		pw += matrix[y][x];
		ids.push('c' + String(x) + ',' + String(y));
		console.log(pw);
		handleEdge(x, y+1, pw, ids, len, matrix, callback); //Move down
	} else if (x === 0) {
		pw += matrix[y][x];
		ids.push('c' + String(x) + ',' + String(y));
		console.log(pw);
		handleEdge(x, y-1, pw, ids, len, matrix, callback); //Move up
	} else if (y >= st.cols-1) {
		pw += matrix[y][x];
		ids.push('c' + String(x) + ',' + String(y));
		console.log(pw);
		handleEdge(x-1, y, pw, ids, len, matrix, callback); //Move left
	} else if (y === 0) {
		pw += matrix[y][x];
		ids.push('c' + String(x) + ',' + String(y));
		console.log(pw);
		handleEdge(x+1, y, pw, ids, len, matrix, callback); //Move right
	}


}

passchars = {
	V: "AEIOU",
	C: "BCDFGHJKLMNPQRSTVWXYZ",
	v: "aeiou",
	c: "bcdfghjklmnpqrstvwxyz",
	A: "AEIOUBCDFGHJKLMNPQRSTVWXYZ",
	a: "AEIOUaeiouBCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz",
	n: "0123456789",
	o: "@&%?,=[]_:-+*$#!'^~;()/.",
	x: "AEIOUaeiouBCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz0123456789!@#$%^&*()",
	" ": " "
};

//Initial settings
st = {
	'rows': 26,  //Either this, or zero index rows/columns
	'cols': 26,
	'charSet': ' ', //Get from form eventually?
	'blankList': generateCharacters(26,26,' '),
	'charList': []
};

//Initialize values, build empty grid
var rows = 26;
var cols = 26;
var charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789[]{}:;>~!@#$%^&*()+=-?<';
var emptyChars = ' '
var charList = generateCharacters(rows,cols,emptyChars);

buildGrid(st.blankList);


//TODO: pull the character generating process out & put them in a data
// structure so they can be iterated over.  List of list?
//TODO: figure out how to create responsive tables for mobile. . . if you just
//go with distributing the HTML page as the cross platform idea
//https://zurb.com/playground/playground/responsive-tables/index.html
//downloaded as responsive-tables.js/.css
//swipe demo is cool here too: https://github.com/filamentgroup/tablesaw



</script>

</body>
</html>